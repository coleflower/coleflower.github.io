{"meta":{"title":"ShenTiePeng's Blog","subtitle":null,"description":null,"author":"ShenTiePeng","url":"https://coleflower.github.io","root":"/"},"pages":[{"title":"about","date":"2019-06-18T07:11:53.000Z","updated":"2019-06-18T07:11:53.072Z","comments":true,"path":"about/index-1.html","permalink":"https://coleflower.github.io/about/index-1.html","excerpt":"","text":""},{"title":"about","date":"2019-06-18T07:11:43.000Z","updated":"2019-06-18T07:37:36.862Z","comments":true,"path":"about/index.html","permalink":"https://coleflower.github.io/about/index.html","excerpt":"","text":"关于我从事 WEB 开发，主要开发语言 JAVA，熟悉使用各种主流框架；有一定的代码洁癖。 对服务端、前端、数据分析等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：上海 关于学习正在往终身学习者前进… 近期学习方向：Java \\ Python (人工智能) 关于座右铭The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好喜欢健身,喜欢树莓派。 联系我Home: minhow.comWeChat: shentiepengEmail: 309869259@qq.comGitHub: coleflower"}],"posts":[{"title":"多线程interrupt()和线程终止方式","slug":"多线程interrupt()和线程终止方式","date":"2019-06-18T16:00:00.000Z","updated":"2019-06-19T09:31:19.467Z","comments":true,"path":"2019/06/19/多线程interrupt()和线程终止方式/","link":"","permalink":"https://coleflower.github.io/2019/06/19/多线程interrupt()和线程终止方式/","excerpt":"","text":"1. interrupt()说明123456interrupt()的作用是中断本线程。本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。 2. 使用interrupt()方法终止线程(阻塞状态和运行状态)​ (1) 阻塞状态 ​ 当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的为止就能终止线程，形式如下：​ 12345678910@Overridepublic void run() &#123; try &#123; while (true) &#123; // 执行任务... &#125; &#125; catch (InterruptedException ie) &#123; // 由于产生InterruptedException异常，退出while(true)循环，线程终止！ &#125;&#125; ​ 在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！ ​ 注意:对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。 123456789101112@Overridepublic void run() &#123; while (true) &#123; try &#123; // 执行任务... &#125; catch (InterruptedException ie) &#123; // InterruptedException在while(true)循环体内。 // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出 break; &#125; &#125;&#125; ​ 可以看出catch(){}中需要添加break;才能跳出循环.对比上面一种需要额外的执行退出while(true)的操作. ​ (2)运行状态 ​ 中断运行状态的线程这边讲两种:通过中断标记和通过额外添加标记 ​ a. 中断标记 123456@Overridepublic void run() &#123; while (!isInterrupted()) &#123; //isInterrupted()为false才能中断线程 // 执行任务... &#125;&#125; ​ 说明：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。 ​ 需要注意的是:interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。(要考,圈起来) ​ b. 额外添加标记 ​ 此方法是采用额外定义一个boolean类型的变量,形式如下: 123456789101112private volatile boolean flag= true;protected void stopTask() &#123; flag = false;&#125;@Overridepublic void run() &#123; while (flag) &#123; // 执行任务... &#125;&#125; ​ 说明:线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。 3. 综合线程处于“阻塞状态”和“运行状态”的终止方式​ 比较通用的终止线程的形式如下： 1234567891011@Overridepublic void run() &#123; try &#123; // 1. isInterrupted()保证，只要中断标记为true就终止线程。 while (!isInterrupted()) &#123; // 执行任务... &#125; &#125; catch (InterruptedException ie) &#123; // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。 &#125;&#125; 4. 终止线程的示例​ a. interrupt()常用来终止”阻塞状态”的线程.形式如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Demo1.java的源码class MyThread extends Thread &#123; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; try &#123; int i=0; while (!isInterrupted()) &#123; Thread.sleep(100); // 休眠100ms i++; System.out.println(Thread.currentThread().getName()+&quot; (&quot;+this.getState()+&quot;) loop &quot; + i); &#125; &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName() +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;); &#125; &#125;&#125;public class Demo1 &#123; public static void main(String[] args) &#123; try &#123; Thread t1 = new MyThread(&quot;t1&quot;); // 新建“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;===================================运行结果===================================t1 (NEW) is new.t1 (RUNNABLE) is started.t1 (RUNNABLE) loop 1t1 (RUNNABLE) loop 2t1 (TIMED_WAITING) is interrupted.t1 (RUNNABLE) catch InterruptedException.t1 (TERMINATED) is interrupted now. ​ 说明: ​ 结果说明： ​ (01) 主线程main中通过new MyThread(“t1”)创建线程t1，之后通过t1.start()启动线程t1。​ (02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。​ (03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。 ​ b. 我们对上面的结果进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Demo2.java的源码class MyThread extends Thread &#123; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i=0; while (!isInterrupted()) &#123; try &#123; Thread.sleep(100); // 休眠100ms &#125; catch (InterruptedException ie) &#123; System.out.println(Thread.currentThread().getName() +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;); &#125; i++; System.out.println(Thread.currentThread().getName()+&quot; (&quot;+this.getState()+&quot;) loop &quot; + i); &#125; &#125;&#125;public class Demo2 &#123; public static void main(String[] args) &#123; try &#123; Thread t1 = new MyThread(&quot;t1&quot;); // 新建“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;=================================运行结果=====================================t1 (NEW) is new.t1 (RUNNABLE) is started.t1 (RUNNABLE) loop 1t1 (RUNNABLE) loop 2t1 (TIMED_WAITING) is interrupted.t1 (RUNNABLE) catch InterruptedException.t1 (RUNNABLE) loop 3t1 (RUNNABLE) loop 4t1 (RUNNABLE) loop 5t1 (TIMED_WAITING) is interrupted now.t1 (RUNNABLE) loop 6t1 (RUNNABLE) loop 7t1 (RUNNABLE) loop 8t1 (RUNNABLE) loop 9... ​ 结果说明:程序进入了死循环！为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。 ​ c. 下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Demo3.java的源码class MyThread extends Thread &#123; private volatile boolean flag= true; public void stopTask() &#123; flag = false; &#125; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; synchronized(this) &#123; try &#123; int i=0; while (flag) &#123; Thread.sleep(100); // 休眠100ms i++; System.out.println(Thread.currentThread().getName()+&quot; (&quot;+this.getState()+&quot;) loop &quot; + i); &#125; &#125; catch (InterruptedException ie) &#123; System.out.println(Thread.currentThread().getName() +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;); &#125; &#125; &#125;&#125;public class Demo3 &#123; public static void main(String[] args) &#123; try &#123; MyThread t1 = new MyThread(&quot;t1&quot;); // 新建“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.stopTask(); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;=================================运行结果=====================================t1 (NEW) is new.t1 (RUNNABLE) is started.t1 (RUNNABLE) loop 1t1 (RUNNABLE) loop 2t1 (TIMED_WAITING) is interrupted.t1 (RUNNABLE) loop 3t1 (TERMINATED) is interrupted now. ​ 参考自skywang12345的分享,感谢博主总结.","categories":[{"name":"多线程","slug":"多线程","permalink":"https://coleflower.github.io/categories/多线程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://coleflower.github.io/tags/多线程/"}],"author":"不穿内裤的超人"},{"title":"了解线程(第一篇)","slug":"了解线程(第一篇)","date":"2019-06-18T16:00:00.000Z","updated":"2019-06-19T09:43:50.414Z","comments":true,"path":"2019/06/19/了解线程(第一篇)/","link":"","permalink":"https://coleflower.github.io/2019/06/19/了解线程(第一篇)/","excerpt":"","text":"线程基础线程的基础概念1. CPU核心和线程数的关系​ 核心数:线程数=1:1 ;使用了超线程技术后—&gt; 1:2 ;简单的说就是一个cpu只能同时处理一个线程. ​ 2. CPU时间片轮转机制​ 又称RR调度，会导致上下文切换. ​ 这里讲下cpu时间片轮转机制的概念: ​ 时间片轮转法（Round-Robin，RR）主要用于分时系统中的进程调度。为了实现轮转调度， 系统把所有就绪进程按先入先出的原则排成一个队列。新来的进程加到就绪队列末尾。每当执行进程调度时，进程调度程序总是选出就绪队列的队首进程，让它在CPU上运行一个时间片的时间。时间片是一个小的时间单位，通常为10~100ms数量级。当进程用完分给它的时间片后，系统的计时器发出时钟中断，调度程序便停止该进程的运行，把它放入就绪队列的末尾；然后，把CPU分给就绪队列的队首进程，同样也让它运行一个时间片，如此往复。 3. 什么是进程和线程​ 进程：程序运行资源分配的最小单位，进程内部有多个线程，会共享这个进程的资源 ​ 线程：CPU调度的最小单位，必须依赖进程而存在。 4. 澄清并行和并发​ 并行：同一时刻，可以同时处理事情的能力 ​ 并发：在单位时间内可以处理事情的能力 ​ 总结一下: ​ 并行指的是一段时间,比如从中午的11点到12点能处理多少线程. ​ 并发指的是同一时刻,比如双十一的00:00这一时刻能处理多少线程. 5. 高并发编程​ 好处：充分利用cpu的资源、加快用户响应的时间，程序模块化，异步化 ​ 问题： ​ 线程共享资源，存在冲突； ​ 容易导致死锁； ​ 启用太多的线程，就有搞垮机器的可能 Java中的线程1. Java天生就是多线程的​ 我们看下下面这个例子: 1234567891011121314151617181920public class OnlyMain &#123; public static void main(String[] args) &#123; ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean(); ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false); for(ThreadInfo threadInfo : threadInfos)&#123; System.out.println(threadInfo.getThreadId()+&quot;:&quot;+threadInfo.getThreadName()); &#125; &#125;&#125;//执行了一次main方法控制台输出如下=============================================================================6:Monitor Ctrl-Break5:Attach Listener4:Signal Dispatcher3:Finalizer2:Reference Handler1:main ​ 我们看到执行一个main方法,并不是只执行了main这一个线程,实际上有6个线程参与了main方法的执行. 2. 实现线程的三个方法​ 我们知道实现线程的方法有继承Thread类和实现runable或者callable接口,为啥可以继承一个类就可以完成的事情,还有要多此一举在写一个runable接口呢,因为Java是单继承了,它只可以继承一个类,但是可以实现多个接口. ​ 通常日常编程中可能Thread和runable用的比较多,callable方法用的比较少,实现callable接口的线程是可以带有返回值得,这里简单写下callable接口具体的实现代码: 123456789101112131415161718192021public class TestA &#123; //callable接口可以定义一个泛型 private static class UseCall implements Callable&lt;String&gt;&#123; @Override public String call() throws Exception &#123; System.out.println(&quot;i am implements Callable&quot;); return &quot;UseCall&quot;; &#125; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; UseCall useCall = new UseCall(); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(useCall); new Thread(futureTask).start(); System.out.println(futureTask.get()); &#125;&#125;=================================运行结果=====================================i am implements CallableUseCall 3.让Java的线程安全的停止工作​ stop()停止方法、resume()继续执行方法、suspend()挂起方法.这三个方法在早期的时候是有的，但现在已被废弃。因为这些方法过于强势，它强行终止一个线程，它是无法保证线程的资源能正常被释放，即线程不会释放资源。（不推荐使用） ​ java线程是协作式，而非抢占式. ​ 调用一个线程的interrupt() 方法中断一个线程，并不是强行关闭这个线程，只是跟这个线程打个招呼，将线程的中断标志位置为true，线程是否中断，由线程本身决定。如果线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。 ​ isInterrupted() 判定当前线程是否处于中断状态。 ​ static方法interrupted() 判定当前线程是否处于中断状态，同时中断标志位改为false。(该方法调用后会将中断标示位清除，即重新设置为false,如果连续两次调用该方法，则第二次调用将返回 false。)。 ​ 对于上面方法的一些概念和使用方法以及其中的坑可以看下LZing_的博客,总结的通俗易懂. ​ 关于interrupt()的详细使用方法可以看下 对线程再多一点点认识1.线程的状态和常用方法: ​ 线程只有5种状态。整个生命周期就是这几种状态的切换。 ​ run()和start() ：run方法就是普通对象的普通方法，只有调用了start()后，Java才会将线程对象和操作系统中实际的线程进行映射，再来执行run方法。 ​ yield() ：让出cpu的执行权，将线程从运行转到可运行状态，但是下个时间片，该线程依然有可能被再次选中运行。 2. 线程的优先级​ 取值为1~10，缺省为5，但线程的优先级不可靠，不建议作为线程开发时候的手段 3. 守护线程​ 和主线程是共死的,比如垃圾回收线程等等. ​ 子线程执行完毕主线程也执行完毕.就算有finally{}也不一定会执行.下面举个例子: 1234567891011121314151617181920212223242526272829303132public class TestB &#123; private static class UseRunable implements Runnable&#123; @Override public void run() &#123; String name = Thread.currentThread().getName(); while (!Thread.currentThread().isInterrupted())&#123; System.out.println(name + &quot;is run&quot;); &#125; &#125; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; UseRunable useRunable = new UseRunable(); Thread endthread = new Thread(useRunable,&quot;endthread&quot;); endthread.setDaemon(true); endthread.start(); Thread.sleep(5); &#125;&#125;=======================================result================================endthreadis runendthreadis runendthreadis runendthreadis runendthreadis runendthreadis runendthreadis run ​ 说明:endthread.setDaemon(true)是将endthread线程设置为守护线程. 主线程main执行结束,endthread作为守护线程也会执行结束.","categories":[{"name":"多线程","slug":"多线程","permalink":"https://coleflower.github.io/categories/多线程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://coleflower.github.io/tags/多线程/"}],"author":"不穿内裤的超人"}]}